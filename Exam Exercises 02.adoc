= 2016-06-14 Exam Exercises 
:stem:
:icons: font
:sectnums:
:sectnumlevels: 2
:pi: pass:q[[.literal]##π##]
:sigma: pass:q[[.literal]##σ##]
:r: pass:q[[.literal]##r##]
:X: ⨝
:and: ∧

****
The following exercises and their solutions were originally authored by _Professor Maria de Marsico_, for the "Basi di Dati" exam session on June, the 14^th^, 2016.

Their translation is ongoing.

****

== Relational Algebra

[.exercise]
--
Consider a database with the following schema, describing a manufacturer's operations:

[source, subs="verbatim, quotes"]
----
PRODUCTS ([underline]#ID#, Description, UnitPrice)
WAREHOUSES ([underline]#ID#, Address)
STOCKS ([underline]#ProductID#, [underline]#WarehouseID#, Units)
----

[NOTE]
====
* The set of each relation's underlined attributes indicates its *key*
* `STOCKS` instances describe how many _products' units_ are stocked and in which _warehouses_. When a product is stocked, its `Units>=1`.
====

Write *relational algebra expressions* for the following queries:

1. For each product whose stock is equal or larger than 10 units, _in any warehouse_, get both:

** the product's data (`ID`, `Description` and `UnitPrice`)
** the addresses of all the warehouses where at least 10 product units are stocked.

2. Find the `ID`, `Description` and `UnitPrice` of the products that _aren't_ stocked at all, anywhere.

TIP: Load a sample https://dbis-uibk.github.io/relax/landing[RelaX] dataset with this gist ID: `126fcdb8c1bedc5080270dff5f642186`
--

=== Answer

Start by identifying the relations that contain needed data. In this case, all of them are required, as:

* `STOCKS` contains the number of stocked units for each product
* `PRODUCTS` holds the data for products details
* `WAREHOUSES` includes the addresses

The easiest query involves:

1. joining the three relations together, via *theta joins* where appropriate
2. performing a *selection* on the resulting relation, by filtering those tuples whose `Units` are equal or higher than 10
3. using a *projection* to pick out the attribute values we require

WARNING: `PRODUCTS` and `WAREHOUSES` both feature an `ID` attribute, although these identify tuples in different relations, with different meanings. It wouldn't make sense to perform a *natural join* between them.

[.answer]
--
Let {r} identify the desired data:

[.relational-algebra]
{r} = {sigma}[.ras]##Units≥10## STOCKS ⨝[.ras]##WarehouseID=ID## WAREHOUSES ⨝[.ras]##ProductID=PRODUCTS.ID## PRODUCTS

A less efficient _alternative_, due to more _joins_, could be:

[.relational-algebra]
{r} = {sigma}[.ras]##Units≥10## (WAREHOUSES ⨝[.ras]##ID=WarehouseID## STOCKS ⨝[.ras]##ProductID=PRODUCTS.ID## PRODUCTS)

We then need to select the relevant attributes, via a *projection* on {r}:

[.relational-algebra]
{pi}[.ras]##PRODUCTS.ID, Description, UnitPrice, Address## ({r})
--

.RelaX Code
[source]
----
r = σ Units >= 10 STOCKS ⨝ WarehouseID = ID WAREHOUSES ⨝ ProductID = PRODUCTS.ID PRODUCTS
π PRODUCTS.ID, Description, UnitPrice, Address (r)
----

=== Answer

TIP: Tackle this class of problems by relying on *set differences*. The tuples that _don't_ meet the selection criteria are first collected and then removed from the set of all the candidate tuples.

In this case we don't need to query the `WAREHOUSES` relation, seeing as it contains no relevant data for our purposes.

WARNING: Products that _aren't_ stocked _don't appear_ in `STOCKS` instances; there are no such tuples whose `Units` value is `0`.

[.answer]
--
Let {r} be the relation which includes the data of all those products we aren't interested in:

[.relational-algebra]
{r} = {pi}[.ras]##ID, Description, UnitPrice## (PRODUCTS ⨝[.ras]##ID=ProductID## STOCKS)

We are selecting *all* the tuples that match stocked products, referenced in `STOCKS` via the `ProductID` attribute. _Unstocked_ products, absent from `STOCKS`, won't be included in the _join_.

We finally *subtract* the data of all stocked products, {r}, from the set of all products (stocked and otherwise):

[.relational-algebra]
PRODUCTS - {r}
--

NOTE: The initial *projection* ensures that the two relations' schemas are *compatible*, as required by the *subtraction*.

.RelaX Code
[source]
----
PRODUCTS - π ID, Description, UnitPrice (PRODUCTS ⨝ ID = ProductID STOCKS)
----

== Relational Theory

[.exercise]

--

Consider the schema R = ABCDEH and the set of functional dependencies:

stem:[F={AC → BD, A → E, B → E, E → D}]


1. demonstrate that ACH is a key

2. knowing that ACH is the only key, demonstrate that R is not in 3NF

3. find a decomposition ρ of R, so that each schema in ρ is in 3NF, F is preserved in ρ, and ρ has a loseless join

--

=== Answer

To prove that a set of attributes X is a key of R, we have to check two
conditions:

a) the closure of X is R

b) there exist no proper subset of X for which a) applies

WARNING: do not forget to demonstrate b)!

we apply the algorithm "computation of X^+^" to X = ACH


Input: stem:[R, F, X] +
Output: stem:[Z = X_F^+]

stem:[Z = X] +
stem:[S = {A | Y rightarrow V ^^ A in V ^^ Y subseteq Z}]

*while* stem:[S] &nsub; stem:[Z] +
&nbsp;&nbsp; *do* +
&nbsp;&nbsp; *begin* +
&nbsp;&nbsp;&nbsp;&nbsp; stem:[Z = Z cup S] +
&nbsp;&nbsp;&nbsp;&nbsp; stem:[S = {A | Y rightarrow V ^^ A in V ^^ Y subseteq Z}] +
&nbsp;&nbsp; *end* +
*end*


Algorithm execution:

stem:[Z = ACH] +
stem:[S = {A | Y rightarrow V ^^ A in V ^^ Y subseteq Z} = {B, D, E}]

stem:[S] &nsub; stem:[Z]

1st iteration:

stem:[Z = Z cup S = ABCDEH] +
stem:[S = {A | Y rightarrow V ^^ A in V ^^ Y subseteq Z} = {B, D, E}]

stem:[S subset Z]

*end*

So, stem:[(ACH)_F^+ = R]


With the same algorithm, we check if the closure of some subset of ACH is
equal to R. We can avoid some calculations by considering that none of the subsets
of ACH that do not contain H can be key, as H does not appear in any
dependency. For the same reason, neither can H be key, as it does not determine any other attribute.
Thus, it is useless (even if it is not wrong) to calculate the closures of A, of C, of H, and of AC.
We still have to check the closures of AH and CH.
Running the algorithm we will have:

stem:[(AH)_F^+ = {A, H, E, D}] +
stem:[(CH)_F^+ = {C, H}]

=== Answer

To show that the schema is not in 3NF, it is sufficient to che that all the
dependencies in F comply with the definition, possibly decomposing the right-hand parts to
obtain signle attributes.

[NOTE]
In fact, it is enough to detect even one depency that does not comply
with the definition to say that the schema is not 3NF!

stem:[AC rightarrow BD in F] +
can be decomposed into: +
stem:[AC rightarrow B in F] and stem:[AC rightarrow D in F]

In both cases, AC is not a superkey, it is actually part of a key, and both B and D are not prime,
so the sceham is not in 3NF.

[NOTE]
If we used the alternative definition, similar considerations could be applied to the
same dependency, which is actually a partial dependency, as AC is a proper subset of a key and
both B and D are not prime.

=== Answer
